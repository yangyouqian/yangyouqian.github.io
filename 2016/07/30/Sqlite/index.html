<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Sqlite | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="在android中使用sqlite数据库之小白的理解笔记1.MyOpenHelper帮助类Create a helper object to create, open, and/or manage a database.利用这个帮助类来创建打开和管理数据库  新建一个项目，同时新建一个类MyOpenHelper继承SQLiteOpenHelper，实现两个方法和构造函数。 public class">
<meta name="keywords">
<meta property="og:type" content="article">
<meta property="og:title" content="Sqlite">
<meta property="og:url" content="http://yoursite.com/2016/07/30/Sqlite/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="在android中使用sqlite数据库之小白的理解笔记1.MyOpenHelper帮助类Create a helper object to create, open, and/or manage a database.利用这个帮助类来创建打开和管理数据库  新建一个项目，同时新建一个类MyOpenHelper继承SQLiteOpenHelper，实现两个方法和构造函数。 public class">
<meta property="og:image" content="http://i.imgur.com/GxTjqBe.png">
<meta property="og:updated_time" content="2016-10-25T13:38:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Sqlite">
<meta name="twitter:description" content="在android中使用sqlite数据库之小白的理解笔记1.MyOpenHelper帮助类Create a helper object to create, open, and/or manage a database.利用这个帮助类来创建打开和管理数据库  新建一个项目，同时新建一个类MyOpenHelper继承SQLiteOpenHelper，实现两个方法和构造函数。 public class">
<meta name="twitter:image" content="http://i.imgur.com/GxTjqBe.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="“-Sqlite" class="article article-type-“" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/30/Sqlite/" class="article-date">
  <time datetime="2016-07-30T13:07:24.000Z" itemprop="datePublished">2016-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Sqlite
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="在android中使用sqlite数据库之小白的理解笔记"><a href="#在android中使用sqlite数据库之小白的理解笔记" class="headerlink" title="在android中使用sqlite数据库之小白的理解笔记"></a>在android中使用sqlite数据库之小白的理解笔记</h2><h4 id="1-MyOpenHelper帮助类"><a href="#1-MyOpenHelper帮助类" class="headerlink" title="1.MyOpenHelper帮助类"></a>1.MyOpenHelper帮助类</h4><p><strong>Create a helper object to create, open, and/or manage a database</strong>.利用这个帮助类来创建打开和管理数据库</p>
<ul>
<li><p>新建一个项目，同时新建一个类MyOpenHelper继承SQLiteOpenHelper，实现两个方法和构造函数。</p>
<pre><code>public class MyOpenHelper extends SQLiteOpenHelper {
    public MyOpenHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) {
        super(context, name, factory, version);
    }

    @Override
    public void onCreate(SQLiteDatabase db) 
        //这个方法会在数据库被创建时调用
        //可以在里面实现创建表
        db.execSQL(&quot;create table clothes(_id integer primary key autoincrement,
                                        type char(20), price char(10),
                                        storage integer(15))&quot;);

    }

    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        //这个方法会在数据库被更新的时候调用
        //可以在里面实现列的添加或者修改表名
    }
</code></pre><p>  }</p>
<ul>
<li><strong>db.execSQL(String sql)</strong>方法： 执行sql语句，不会返回数据。</li>
<li>文档中的解释：<br><strong>Execute a single SQL statement that is NOT a SELECT or any other SQL statement that returns data.</strong><ul>
<li><strong>sqlite创建表的语句</strong>：</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>create table table_name(
   column1 datatype  PRIMARY KEY(one or more columns),
   column2 datatype,
   column3 datatype,
   .....
   columnN datatype,
);
//create table 是告诉数据库系统创建一个新表的关键字。
//create table 语句后跟着表的唯一的名称或标识。
</code></pre><h4 id="2-在Android-Studio单元测试框架中进行数据库的增删改查"><a href="#2-在Android-Studio单元测试框架中进行数据库的增删改查" class="headerlink" title="2.在Android Studio单元测试框架中进行数据库的增删改查"></a>2.在Android Studio单元测试框架中进行数据库的增删改查</h4><p><img src="http://i.imgur.com/GxTjqBe.png" alt=""></p>
<p>我用的是AS2.1.1版本，在ApplicationTest中<br>创建方法<strong>public void test()</strong>,在test方法中编写测试代码，然后再右键test方法运行即可。</p>
<h5 id="两个测试框架中的方法"><a href="#两个测试框架中的方法" class="headerlink" title="两个测试框架中的方法"></a>两个测试框架中的方法</h5><pre><code>//测试框架初始化完毕之后，在测试方法执行之前，此方法调用
    @Override
    protected void setUp() throws Exception {
        super.setUp();
        oh = new MyOpenHelper(getContext(), &quot;shop.db&quot;, null, 2);
        db = oh.getWritableDatabase();//获取到数据库对象
    }
//测试框架测试方法运行完毕之后，此方法调用
@Override
    protected void tearDown() throws Exception {
        super.tearDown();
    }
</code></pre><ul>
<li><p>这里new出MyOpenHelper帮助类的时候传入的参数：</p>
<ul>
<li><strong>getContext()</strong>:获得一个虚拟的上下文。<ul>
<li>to use to open or create the database</li>
</ul>
</li>
<li><strong>“shop.db”</strong>：创建的数据库表名</li>
<li><strong>null(factory)：</strong>传null表示使用默认的。<ul>
<li>to use for creating cursor objects, or null for the default</li>
</ul>
</li>
<li><strong>2/版本号</strong>：至少为1。<ul>
<li>number of the database (starting at 1); </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>getWritableDatabase()</strong>：用来创建或者打开数据库，如果数据库不存在就创建一个可读可写的数据库，存在就打开。</p>
<ul>
<li>Create and/or open a database that will be used for reading and writing.</li>
</ul>
</li>
<li>还有一个<strong>getReadableDatabase()</strong>方法，差别在于，如果存储空间满了，那么返回只读数据库对象，其他与getWritableDatabase()一样。</li>
</ul>
<h4 id="增删改查第一种方法之直接执行sqlite语句"><a href="#增删改查第一种方法之直接执行sqlite语句" class="headerlink" title="增删改查第一种方法之直接执行sqlite语句"></a>增删改查第一种方法之直接执行sqlite语句</h4><ul>
<li><p><strong>insert</strong>：</p>
<pre><code>public void insert(String type, String price, int storage){
    //?：占位符
        db.execSQL(&quot;insert into clothes (type, price, storage)values(?, ?, ?)&quot;,
            new Object[]{type, price, storage});//传入需要插入的值
    }
</code></pre></li>
</ul>
<ul>
<li><p><strong>delete</strong>:</p>
<pre><code>public void delete(String type){
    db.execSQL(&quot;delete from clothes where type = ?&quot;, new Object[]{type});
}
</code></pre></li>
<li><p><strong>update</strong>:</p>
<pre><code>public void update(){
        db.execSQL(&quot;update clothes set _id = ? where type = ?&quot;,
                 n ew Object[]{3 , &quot;内裤&quot;});
}
</code></pre></li>
<li><p><strong>select</strong>:</p>
<pre><code>public void select(){
    Cursor cursor = db.rawQuery(&quot;select type, price from clothes&quot;, null);
    while (cursor.moveToNext()){
        String type = cursor.getString(cursor.getColumnIndex(&quot;type&quot;));
        String price = cursor.getString(cursor.getColumnIndex(&quot;price&quot;));
        System.out.println(type+&quot;;&quot;+price);
    }
    }

//查询方法和之前的有点不一样，是用rawQuery()方法执行提供的sql语句，然后返回一个Cursor对象
 Runs the provided SQL and returns a Cursor over the result set
</code></pre><h4 id="增删改查第二张方法之调用API"><a href="#增删改查第二张方法之调用API" class="headerlink" title="增删改查第二张方法之调用API"></a>增删改查第二张方法之调用API</h4><p>调用API方法来进行增删改查，因为方法会返回一些数据，可以通过判断返回的数据是否等于想要得到的效果来编写相应的逻辑代码，可以防止因sql的语句出现错误导致的bug，不过实际上调用的API方法是系统封装好了的，底层还是在拼接sql语句并执行。</p>
</li>
<li><p><strong>insert</strong>：</p>
<pre><code>&gt; public long insert (String table, String nullColumnHack, ContentValues values)
</code></pre></li>
</ul>
<p><strong>return</strong>:the row ID of the newly inserted row, or -1 if an error occurred<br>这个方法会返回插入的行数，如果没有插入成功则返回-1</p>
<p><em>nullColumnHack</em>:只有在插入的values都为空的时候才用的上,基本上用不上</p>
<blockquote>
<p> 文档解释：If your provided values is empty, no column names are known and an empty row can’t be inserted. If not set to null, the nullColumnHack parameter provides the name of nullable column name to explicitly insert a NULL into in the case where your values is empty.</p>
</blockquote>
<pre><code>public void insertByAPI(){
    ContentValues values = new ContentValues();
    //ContentValues is used to store a set of values。存储键值对
    values.put(&quot;type&quot;,&quot;内裤&quot;);
    //put(key, value);前面这个key一定要是表列名，后面是要插入的值
    values.put(&quot;storage&quot;, &quot;20&quot;);
    values.put(&quot;price&quot;, 23);
    db.insert(&quot;clothes&quot;, null, values);
}
</code></pre><ul>
<li><p><strong>delete</strong>：</p>
<pre><code>public int deleteByAPI(){
    int i = db.delete(&quot;clothes&quot;,&quot;type = ? and _id = ?&quot;, 
                        new String[]{&quot;中裤&quot;,&quot;3&quot;});
    return i;
}
</code></pre></li>
<li><p><strong>update:</strong></p>
<pre><code>public void updateByAPI(){
    ContentValues values = new ContentValues();
    values.put(&quot;type&quot;, &quot;上衣&quot;);
    db.update(&quot;clothes&quot;, values, &quot;_id = ?&quot;, new String[]{&quot;2&quot;});
}
</code></pre></li>
<li><p><strong>select:</strong></p>
<pre><code>public void selectByAPI(){
    Cursor cursor = db.query(&quot;clothes&quot;,null,null, null,null,null,null,null);
    while (cursor.moveToNext()){
        String type = cursor.getString(cursor.getColumnIndex(&quot;type&quot;));
        String price = cursor.getString(cursor.getColumnIndex(&quot;price&quot;));
        System.out.println(type+&quot;;&quot;+price);
    }
}
</code></pre></li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h6 id="sqlite是一个轻量级的数据库，内置于android应用中，会随着app的卸载而不存在。由于内存很小，所以也舍弃了一些功能，比如不会检查类型是否对应，插入数据时，integer类型可以插入char类型当中。"><a href="#sqlite是一个轻量级的数据库，内置于android应用中，会随着app的卸载而不存在。由于内存很小，所以也舍弃了一些功能，比如不会检查类型是否对应，插入数据时，integer类型可以插入char类型当中。" class="headerlink" title="sqlite是一个轻量级的数据库，内置于android应用中，会随着app的卸载而不存在。由于内存很小，所以也舍弃了一些功能，比如不会检查类型是否对应，插入数据时，integer类型可以插入char类型当中。"></a>sqlite是一个轻量级的数据库，内置于android应用中，会随着app的卸载而不存在。由于内存很小，所以也舍弃了一些功能，比如不会检查类型是否对应，插入数据时，integer类型可以插入char类型当中。</h6><h5 id="总的来说，在android中使用sqlite，需要先建一个帮助类在完成数据库的创建和打开，管理。然后通过getWritableDatabase-获取数据库，然后对其进行增删改查操作。"><a href="#总的来说，在android中使用sqlite，需要先建一个帮助类在完成数据库的创建和打开，管理。然后通过getWritableDatabase-获取数据库，然后对其进行增删改查操作。" class="headerlink" title="总的来说，在android中使用sqlite，需要先建一个帮助类在完成数据库的创建和打开，管理。然后通过getWritableDatabase()获取数据库，然后对其进行增删改查操作。"></a>总的来说，在android中使用sqlite，需要先建一个帮助类在完成数据库的创建和打开，管理。然后通过getWritableDatabase()获取数据库，然后对其进行增删改查操作。</h5><hr>
<ul>
<li>sqlite相关知识来源于菜鸟教程：<a href="http://www.runoob.com/sql/sql-tutorial.html" title="菜鸟教程" target="_blank" rel="external">http://www.runoob.com/sql/sql-tutorial.html</a></li>
<li>文中的英文解释皆出自官方文档</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/30/Sqlite/" data-id="cj1ox8n3l0000wkvi6ybn85bg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/10/25/坑总是接二连三的来让你踩/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">坑总是接二连三的来让你踩</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">July 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/19/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2016/11/03/android-Dalvik/">android Dalvik</a>
          </li>
        
          <li>
            <a href="/2016/10/25/坑总是接二连三的来让你踩/">坑总是接二连三的来让你踩</a>
          </li>
        
          <li>
            <a href="/2016/07/30/Sqlite/">Sqlite</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>